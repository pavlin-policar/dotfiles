#!/usr/bin/python
import os
import pickle
import sys
from argparse import ArgumentParser
from os.path import join, isdir, expanduser
from typing import Dict

from youtube_dl import YoutubeDL

PLAYLISTS = {
    '2014': 'PLvExg6gsBjAccJ7o4HpDptNlsxDN27rCL',
    'classical': 'PLvExg6gsBjAd-Z_iHGKGc3hWnhrDf7qDZ',
    'sad_piano': 'PLh9R0KdDnt85ganQeuun2ceutPqvCbxrw',
    'old': 'PLCA48A738B499BE6D',
}
PLAYLISTS_DIR = join('~', 'Music')


def _print_progress(current_idx, total_songs, song_title):
    # Clear the line from the previous download
    sys.stdout.write('\r' + ' ' * 80)
    sys.stdout.flush()
    # We show the currently being downloaded song
    sys.stdout.write(
        '\r[%d/%d] %s' % (current_idx, total_songs, song_title)
    )
    sys.stdout.flush()


class Playlist:
    DATA_FILE_NAME = 'data.p'

    def __init__(self, playlist_info: Dict, directory: str, ytl: YoutubeDL):
        self.id = playlist_info['id']
        self.name = playlist_info['title']
        self.uploader = playlist_info['uploader']
        self.directory = join(directory, self.name)
        self.data_file = join(self.directory, self.DATA_FILE_NAME)

        self._upstream_data = {
            entry['id']: Song(entry, ytl, playlist=self)
            for entry in playlist_info['entries']
        }
        self._local_data = {}

        self.__ytl = ytl

        # Attempt to read pickled list of song data from fs, otherwise assume
        # no songs have been downloaded
        try:
            with open(self.data_file, 'rb') as file:
                loaded_data = pickle.load(file)
                # Check that the loaded playlist is the same as this one
                assert loaded_data['id'] == self.id
                assert loaded_data['name'] == self.name
                self._local_data = {
                    song_id: Song.from_info(
                        loaded_data['songs'][song_id], ytl, playlist=self
                    )
                    for song_id in loaded_data['songs']
                }
        except FileNotFoundError:
            pass
        except (EOFError, TypeError):
            # If the data is corrupt, there's nothing we can do, so remove it
            os.remove(self.data_file)

        self.__local_ids = set(self._local_data.keys())
        self.__upstream_ids = set(self._upstream_data.keys())

        self.__synced_song_ids = self.__upstream_ids & self.__local_ids
        self.__to_remove_song_ids = self.__local_ids - self.__upstream_ids
        self.__to_download_song_ids = self.__upstream_ids - self.__local_ids

    @property
    def synced(self):
        return [self._local_data[song_id] for song_id in self._local_data
                if song_id in self.__synced_song_ids]

    @property
    def to_remove(self):
        return [self._local_data[song_id] for song_id in self._local_data
                if song_id in self.__to_remove_song_ids]

    @property
    def to_download(self):
        return [self._upstream_data[song_id] for song_id in self._upstream_data
                if song_id in self.__to_download_song_ids]

    def sync(self):
        for idx, song in enumerate(self.to_download):
            _print_progress(idx + 1, len(self.to_download), song.title)
            song.download()
            self._local_data[song.id] = song

            with open(self.data_file, 'wb') as file:
                pickle.dump(self.info(), file)

    def info(self):
        return {
            'id': self.id,
            'name': self.name,
            'songs': {
                song_id: self._local_data[song_id].info()
                for song_id in self._local_data
            },
        }


class Song:
    def __init__(self, song_info: Dict, ytl: YoutubeDL, playlist: Playlist = None):
        self.id = song_info['id']
        self.title = song_info['title']
        self.url = song_info['url']
        self.playlist = playlist

        self.__data = song_info
        self.__ytl = ytl

    def download(self):
        info_extractor = self.__ytl.get_info_extractor(self.__data['ie_key'])

        assert info_extractor.suitable(self.url), \
            'Info extractor is not suitable for song %s' % self.url

        ie_result = info_extractor.extract(self.url)

        if self.playlist:
            self.__ytl.add_extra_info(ie_result, {'playlist': self.playlist.name})

        self.__ytl.process_video_result(ie_result, download=True)

    def info(self):
        return {'id': self.id, 'title': self.title, 'url': self.url}

    @classmethod
    def from_info(cls, info: Dict, ytl: YoutubeDL, playlist: Playlist = None):
        return cls(info, ytl, playlist)


def sync(playlist):
    playlist.sync()


def check(playlist):
    print('%s by %s' % (playlist.name, playlist.uploader))
    print('Synced songs: %d' % len(playlist.synced))
    print('Songs to remove: %d' % len(playlist.to_remove))
    print('Songs to download: %d' % len(playlist.to_download))


def __get_playlist_info(ytl, playlist_name):
    """Extract the relevant playlist info to be used."""
    ie = ytl.get_info_extractor('YoutubePlaylist')
    playlist_url = PLAYLISTS[playlist_name]

    assert ie.suitable(playlist_url), \
        'The info extractor is not suitable for the given URL. Are you sure ' \
        'you provided a valid playlist id?'

    playlist_info = ie.extract(playlist_url)
    playlist_info['entries'] = list(playlist_info['entries'])
    return playlist_info


ACTIONS = {'sync': sync, 'check': check}


def __parse_arguments():
    parser = ArgumentParser(
        description='Keep your local music playlist synchronized with your '
                    'youtube playlists.',
    )
    parser.add_argument(
        'action', metavar='action', type=str, choices=ACTIONS.keys(),
        help='action to perform',
    )
    parser.add_argument(
        'name', metavar='name', type=str, choices=PLAYLISTS.keys(),
        help='playlist name',
    )
    parser.add_argument(
        '--dir', default=PLAYLISTS_DIR,
        help='specify the directory where playlists are located'
    )
    args = parser.parse_args()

    # Convert the ~ to the user path, so that `isdir` works properly
    args.dir = expanduser(args.dir)
    assert isdir(args.dir), 'The path specified is not a valid directory!'

    return args


def __main():
    args = __parse_arguments()

    ytl = YoutubeDL({
        # 'quiet': True,
        'outtmpl': join(args.dir, '%(playlist)s/%(title)s.%(ext)s'),
        'nooverwrites': True,
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
        }]
    })

    playlist_info = __get_playlist_info(ytl, args.name)
    playlist = Playlist(playlist_info, args.dir, ytl)

    ACTIONS[args.action](playlist)


if __name__ == '__main__':
    __main()
