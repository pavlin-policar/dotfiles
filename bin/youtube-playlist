#!/usr/bin/python
import re
import subprocess
import sys
from argparse import ArgumentParser
from os.path import join, isdir, expanduser

PLAYLISTS = {
    '2014': 'PLvExg6gsBjAccJ7o4HpDptNlsxDN27rCL',
    'classical': 'PLvExg6gsBjAd-Z_iHGKGc3hWnhrDf7qDZ',
    'sad_piano': 'PLh9R0KdDnt85ganQeuun2ceutPqvCbxrw',
    'old': 'PLCA48A738B499BE6D',
}
PLAYLISTS_DIR = join('~', 'Music')


def __num_total_videos(playlist_name):
    cmd = ['youtube-dl', '--flat-playlist', PLAYLISTS[playlist_name]]

    output = subprocess.check_output(cmd)
    # We get a bytes-like object separated by \n
    output = str(output).split('\\n')

    # Find the entry that states the number of videos in playlist
    pattern = re.compile(r'Downloading (\d+) videos', flags=re.IGNORECASE)
    for string in output:
        match = re.search(pattern, string)
        if match:
            return int(match.group(1))
    # If we weren't able to find the correct line, the output may have changed
    else:
        raise RuntimeError(
            'Was not able to get number of total songs. Has the output of '
            '`youtube-dl` changed?'
        )


def __cleanup_parts(directory):
    """Remove any leftover *.fxx.* video files from directory."""
    # find . -name '*.f*.*' -delete
    subprocess.call(['find', directory, '-name', '*.f*.*', '-delete'])


def __print_progress(current_idx, total_songs, song_title):
    # Clear the line from the previous download
    sys.stdout.write('\r' + ' ' * 80)
    sys.stdout.flush()
    # We show the currently being downloaded song
    sys.stdout.write(
        '\r[%d/%d] %s' % (current_idx, total_songs, song_title)
    )
    sys.stdout.flush()


def fetch(playlist_name, directory, **_):
    # Specify the `youtube-dl` output format
    output_format = '%(playlist)s/%(title)s.%(ext)s'
    output_path = join(directory, output_format)

    cmd = [
        'youtube-dl',
        # Continue on download errors
        '--ignore-errors',
        '-o', output_path,
        # Keep the downloaded video files, so it does not re-download them
        # again when running a second time
        '--keep-video',
        # Do not overwrite the already downloaded video files, simply skip
        # download
        '--no-overwrites',
        '--extract-audio',
        '--audio-format', 'mp3',
        # Do not overwrite the extracted audio files
        '--no-post-overwrites',
        PLAYLISTS[playlist_name],
    ]

    # NOTE: These regexes are heavily dependent on the output of `youtube-dl`
    download_progress = re.compile(
        r'video (\d+) of (\d+)', flags=re.IGNORECASE
    )
    # TODO: This does not work when the title contains a dot
    # NOTE: This matches the `part` files, however this is not an issue, since
    # the title remains the same and the contents of the previous match is
    # overridden. The same is true for the `already_downloaded` pattern.
    title = re.compile(
        r'\[download\] Destination:.*\/(.+?)\.', flags=re.IGNORECASE
    )
    already_downloaded = re.compile(
        r'\[download\].*\/(.+?)\..*has already been', flags=re.IGNORECASE
    )

    with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as process:
        for line in iter(process.stdout.readline, ''):
            # Line is read as bytes, so we need to convert to string before any
            # kind of manipulation
            line = line.decode('utf-8')

            download_status_match = re.search(download_progress, line)
            if download_status_match:
                current_idx = int(download_status_match.group(1))
                total_songs = int(download_status_match.group(2))

            title_match = re.search(title, line)
            already_downloaded_match = re.search(already_downloaded, line)
            if title_match or already_downloaded_match:
                song_title = title_match.group(1) if title_match \
                    else already_downloaded_match.group(1)
                # We notify the user of the currently being downloaded song
                __print_progress(current_idx, total_songs, song_title)


def __main():
    # Register the supported actions
    actions = {'fetch': fetch}

    parser = ArgumentParser(
        description='Keep your local music playlist synchronized with your '
                    'youtube playlists.',
    )
    parser.add_argument(
        'action', metavar='action', type=str, choices=actions.keys(),
        help='action to perform',
    )
    parser.add_argument(
        'name', metavar='name', type=str, choices=PLAYLISTS.keys(),
        help='playlist name',
    )
    parser.add_argument(
        '--dir', default=PLAYLISTS_DIR,
        help='specify the directory where playlists are located'
    )
    args = parser.parse_args()

    # Convert the ~ to the user path, so that `isdir` works properly
    args.dir = expanduser(args.dir)
    assert isdir(args.dir), 'The path specified is not a valid directory!'

    actions[args.action](args.name, directory=args.dir)


if __name__ == '__main__':
    __main()
